{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to RCJ Soccer Sim! The RoboCupJunior Soccer Simulator is an attempt at playing RoboCupJunior Soccer in a virtualized environment. It is an experimental project organized by the RoboCupJunior Soccer Technical Committe. The simulator is based on Webots . The associated repository provides both the \"automatic referee\" (which implements the Soccer Simulated Rules ) as well as a sample team of robots with some basic simulated strategy. How do I try this out? Installation Install Python 3.7 (or higher) 64 bit from the official website (please make sure it is version 3.7 or higher for Windows, and 3.8 or higher if installing on MacOS or Linux). On Windows, please make sure your Python is referenced in Windows PATH by selecting the option \"Add Python 3.x to PATH\" during the installation. Check out this great installation guide if you need some help! Download Webots from their official website. Currently, version r2021a is stable with the Soccer Simulator. You can find detailed installation procedure on the official Webots Installation guide . Clone the rcj-soccer-sim repository to your computer by downloading the ZIP file from here or running git clone https://github.com/RoboCupJuniorTC/rcj-soccer-sim.git Finally, run Webots, go to Tools > Preferences > Python command and set it to python or python3 to point Webots to Python 3. Depending on your system, the reference to Python 3 can be via the command python or python3 . More information on how to configure Webots to work with Python can be found here . Running Soccer Sim Use Webots to open the downloaded soccer.wbt world located in the worlds directory (via File > Open World ) Run/pause the simulation by clicking the corresponding buttons on the top-part of Webots window. Note that the controllers that are responsible for the various robots on the field can be found in the controllers/ directory. Notes A specific webots world can be executed directly from the command line as follows: webots --mode=run worlds/soccer.wbt Which allows for at least some automation. Further info can be found in the docs . The sample players as well as the \"automatic referee\" are implemented in Python, which should allow for easily updating the code to match the rules and avoid any compilation issues.","title":"Welcome to RCJ Soccer Sim!"},{"location":"#welcome-to-rcj-soccer-sim","text":"The RoboCupJunior Soccer Simulator is an attempt at playing RoboCupJunior Soccer in a virtualized environment. It is an experimental project organized by the RoboCupJunior Soccer Technical Committe. The simulator is based on Webots . The associated repository provides both the \"automatic referee\" (which implements the Soccer Simulated Rules ) as well as a sample team of robots with some basic simulated strategy.","title":"Welcome to RCJ Soccer Sim!"},{"location":"#how-do-i-try-this-out","text":"","title":"How do I try this out?"},{"location":"#installation","text":"Install Python 3.7 (or higher) 64 bit from the official website (please make sure it is version 3.7 or higher for Windows, and 3.8 or higher if installing on MacOS or Linux). On Windows, please make sure your Python is referenced in Windows PATH by selecting the option \"Add Python 3.x to PATH\" during the installation. Check out this great installation guide if you need some help! Download Webots from their official website. Currently, version r2021a is stable with the Soccer Simulator. You can find detailed installation procedure on the official Webots Installation guide . Clone the rcj-soccer-sim repository to your computer by downloading the ZIP file from here or running git clone https://github.com/RoboCupJuniorTC/rcj-soccer-sim.git Finally, run Webots, go to Tools > Preferences > Python command and set it to python or python3 to point Webots to Python 3. Depending on your system, the reference to Python 3 can be via the command python or python3 . More information on how to configure Webots to work with Python can be found here .","title":"Installation"},{"location":"#running-soccer-sim","text":"Use Webots to open the downloaded soccer.wbt world located in the worlds directory (via File > Open World ) Run/pause the simulation by clicking the corresponding buttons on the top-part of Webots window. Note that the controllers that are responsible for the various robots on the field can be found in the controllers/ directory.","title":"Running Soccer Sim"},{"location":"#notes","text":"A specific webots world can be executed directly from the command line as follows: webots --mode=run worlds/soccer.wbt Which allows for at least some automation. Further info can be found in the docs . The sample players as well as the \"automatic referee\" are implemented in Python, which should allow for easily updating the code to match the rules and avoid any compilation issues.","title":"Notes"},{"location":"how_to/","text":"How to program your robot Controllers Each object in the simulation world can be controlled by a program. This program is called Controller . Each robot should have exactly one controller, implemented as a Python3 program. There is an invisible referee object in the simulation, which takes care of controlling the game and checking the rules. The controllers are located in the controllers directory. The name of the controller must be located in a subfolder with the same name (i.e. my_controller/my_controller.py ) and this name ought to be specified in soccer.wbt file. Hello world, robot! We have prepared a few sample robot controllers. They can be found in the controllers directory. Each controller is prefixed with rcj_soccer_player_ . They are all programmed in the same way, meaning they rotate to face the ball and then goes towards it. We decided to make the code reusable and put some common methods into the RCJSoccerRobot class inside rcj_soccer_robot.py file. Let's put together a simple program to showcase how you can go about programming a robot. from controller import Robot import struct TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) class MyRobot : def __init__ ( self ): self . robot = Robot () self . name = self . robot . getName () self . receiver = self . robot . getDevice ( \"receiver\" ) self . receiver . enable ( TIME_STEP ) self . left_motor = self . robot . getDevice ( \"left wheel motor\" ) self . right_motor = self . robot . getDevice ( \"right wheel motor\" ) self . left_motor . setPosition ( float ( '+inf' )) self . right_motor . setPosition ( float ( '+inf' )) self . left_motor . setVelocity ( 0.0 ) self . right_motor . setVelocity ( 0.0 ) def get_new_data ( self ): packet = self . receiver . getData () self . receiver . nextPacket () struct_fmt = 'ddd' * 6 + 'dd' unpacked = struct . unpack ( struct_fmt , packet ) data = {} for i , r in enumerate ( ROBOT_NAMES ): data [ r ] = { \"x\" : unpacked [ 3 * i ], \"y\" : unpacked [ 3 * i + 1 ], \"orientation\" : unpacked [ 3 * i + 2 ] } data [ \"ball\" ] = { \"x\" : unpacked [ 3 * N_ROBOTS ], \"y\" : unpacked [ 3 * N_ROBOTS + 1 ] } return data def run ( self ): while self . robot . step ( TIME_STEP ) != - 1 : if self . receiver . getQueueLength () > 0 : data = self . get_new_data () # Get the position of our robot robot_pos = data [ self . name ] # Get the position of the ball ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) my_robot = MyRobot () my_robot . run () Let's explain the code in detail: from controller import Robot The Robot class is required to be imported because this is the only way we are able to controll the robot. The Robot class is shipped together with Webots. import struct This library is a built-in Python library , which is required to unpack the data sent by the supervisor. TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) We also define some useful constants, whose values will be used later. class MyRobot : You can wrap the program into the class as we did. The benefit of OOP ( Object Oriented Programming ) is that you can later reuse the same common class throughout your controllers and therefore make the code easier to read. We are going to continue with our OOP approach. def __init__ ( self ): self . robot = Robot () self . name = self . robot . getName () ... The __init__ function is something like a constructor of the class and is called when an instance of the MyRobot object is created. We use this function to initialize some important variables. The most important one is the Robot instance, which allows us to get access to the so called Webots devices like motor (for controlling the speed) or receiver (for reading data from Supervisor). The name and the team of your robot can be determined by calling self.robot.getName() . It will give you one of {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . The first letter determines the team (\"Blue\", \"Yellow\"), while the second one is the robot's identifier. def get_new_data ( self ): ... We are not going to explain this deeply. This function is to parse the incoming data from supervisor. Feel free to copy and use it. The resulting dictionary contains positions of all of the robots as well as the position of the ball. def run ( self ): This is the method which contains the logic for controlling the robot. while self . robot . step ( TIME_STEP ) != - 1 : The step function is crucial and must be used in every controller. This function synchronizes the sensor and actuator data between Webots and the controllers. if self . receiver . getQueueLength () > 0 : Before reading data, it is important to check if there is actually something in the queue that we can read. data = self . get_new_data () robot_pos = data [ self . name ] ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) And finally, after reading the new data received from supervisor, we do some calculations and set the speed of the motors. my_robot = MyRobot () my_robot . run () In the very end of our program, we initialize the robot and call the method run in order to execute the code. Importing shared code Each team consists of three robots. These robots might share some of the code and it is actually a good practice not to duplicate code all over the place. Imagine you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3/ \u2502 \u2514\u2500\u2500 robot3.py and within robot2.py you want to import some useful code from utils.py located in the robot1 folder. This is possible, but you need to put the following code snippet right at the top of your robot2.py file. import sys from pathlib import Path sys . path . append ( str ( Path ( '.' ) . absolute () . parent )) from robot1 import utils This will ensure that the code from robot1 is importable (it adds the parent folder to the Python PATH -- the list of folders where Python looks when importing modules). If you want to import utils within robot1 , you do no have to add these magic lines to robot1.py , but instead just call import utils because the PATH actually contains the folder of the script which is being run.","title":"How to program your robot"},{"location":"how_to/#how-to-program-your-robot","text":"","title":"How to program your robot"},{"location":"how_to/#controllers","text":"Each object in the simulation world can be controlled by a program. This program is called Controller . Each robot should have exactly one controller, implemented as a Python3 program. There is an invisible referee object in the simulation, which takes care of controlling the game and checking the rules. The controllers are located in the controllers directory. The name of the controller must be located in a subfolder with the same name (i.e. my_controller/my_controller.py ) and this name ought to be specified in soccer.wbt file.","title":"Controllers"},{"location":"how_to/#hello-world-robot","text":"We have prepared a few sample robot controllers. They can be found in the controllers directory. Each controller is prefixed with rcj_soccer_player_ . They are all programmed in the same way, meaning they rotate to face the ball and then goes towards it. We decided to make the code reusable and put some common methods into the RCJSoccerRobot class inside rcj_soccer_robot.py file. Let's put together a simple program to showcase how you can go about programming a robot. from controller import Robot import struct TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) class MyRobot : def __init__ ( self ): self . robot = Robot () self . name = self . robot . getName () self . receiver = self . robot . getDevice ( \"receiver\" ) self . receiver . enable ( TIME_STEP ) self . left_motor = self . robot . getDevice ( \"left wheel motor\" ) self . right_motor = self . robot . getDevice ( \"right wheel motor\" ) self . left_motor . setPosition ( float ( '+inf' )) self . right_motor . setPosition ( float ( '+inf' )) self . left_motor . setVelocity ( 0.0 ) self . right_motor . setVelocity ( 0.0 ) def get_new_data ( self ): packet = self . receiver . getData () self . receiver . nextPacket () struct_fmt = 'ddd' * 6 + 'dd' unpacked = struct . unpack ( struct_fmt , packet ) data = {} for i , r in enumerate ( ROBOT_NAMES ): data [ r ] = { \"x\" : unpacked [ 3 * i ], \"y\" : unpacked [ 3 * i + 1 ], \"orientation\" : unpacked [ 3 * i + 2 ] } data [ \"ball\" ] = { \"x\" : unpacked [ 3 * N_ROBOTS ], \"y\" : unpacked [ 3 * N_ROBOTS + 1 ] } return data def run ( self ): while self . robot . step ( TIME_STEP ) != - 1 : if self . receiver . getQueueLength () > 0 : data = self . get_new_data () # Get the position of our robot robot_pos = data [ self . name ] # Get the position of the ball ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) my_robot = MyRobot () my_robot . run () Let's explain the code in detail: from controller import Robot The Robot class is required to be imported because this is the only way we are able to controll the robot. The Robot class is shipped together with Webots. import struct This library is a built-in Python library , which is required to unpack the data sent by the supervisor. TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) We also define some useful constants, whose values will be used later. class MyRobot : You can wrap the program into the class as we did. The benefit of OOP ( Object Oriented Programming ) is that you can later reuse the same common class throughout your controllers and therefore make the code easier to read. We are going to continue with our OOP approach. def __init__ ( self ): self . robot = Robot () self . name = self . robot . getName () ... The __init__ function is something like a constructor of the class and is called when an instance of the MyRobot object is created. We use this function to initialize some important variables. The most important one is the Robot instance, which allows us to get access to the so called Webots devices like motor (for controlling the speed) or receiver (for reading data from Supervisor). The name and the team of your robot can be determined by calling self.robot.getName() . It will give you one of {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . The first letter determines the team (\"Blue\", \"Yellow\"), while the second one is the robot's identifier. def get_new_data ( self ): ... We are not going to explain this deeply. This function is to parse the incoming data from supervisor. Feel free to copy and use it. The resulting dictionary contains positions of all of the robots as well as the position of the ball. def run ( self ): This is the method which contains the logic for controlling the robot. while self . robot . step ( TIME_STEP ) != - 1 : The step function is crucial and must be used in every controller. This function synchronizes the sensor and actuator data between Webots and the controllers. if self . receiver . getQueueLength () > 0 : Before reading data, it is important to check if there is actually something in the queue that we can read. data = self . get_new_data () robot_pos = data [ self . name ] ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) And finally, after reading the new data received from supervisor, we do some calculations and set the speed of the motors. my_robot = MyRobot () my_robot . run () In the very end of our program, we initialize the robot and call the method run in order to execute the code.","title":"Hello world, robot!"},{"location":"how_to/#importing-shared-code","text":"Each team consists of three robots. These robots might share some of the code and it is actually a good practice not to duplicate code all over the place. Imagine you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3/ \u2502 \u2514\u2500\u2500 robot3.py and within robot2.py you want to import some useful code from utils.py located in the robot1 folder. This is possible, but you need to put the following code snippet right at the top of your robot2.py file. import sys from pathlib import Path sys . path . append ( str ( Path ( '.' ) . absolute () . parent )) from robot1 import utils This will ensure that the code from robot1 is importable (it adds the parent folder to the Python PATH -- the list of folders where Python looks when importing modules). If you want to import utils within robot1 , you do no have to add these magic lines to robot1.py , but instead just call import utils because the PATH actually contains the folder of the script which is being run.","title":"Importing shared code"}]}